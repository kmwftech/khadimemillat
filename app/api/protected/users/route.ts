import { NextRequest, NextResponse } from "next/server";
import { clerkClient } from '@clerk/nextjs/server';
import connectDB from '@/lib/db';
import User from '@/models/User';
import { z } from 'zod';

// Schema: client supplies a full name and mobile number only
const userQuickCreateSchema = z.object({
  name: z.string().min(2).max(120),
  mobile: z.string().min(7).max(20).regex(/^[0-9+\-() ]+$/),
});

// Helper to derive first/last names, email, username, password
function deriveIdentity(name: string, mobile: string) {
  const trimmed = name.trim();
  const parts = trimmed.split(/\s+/);
  const firstName = parts[0];
  const lastName = parts.length > 1 ? parts[parts.length - 1] : '';
  const digits = mobile.replace(/\D/g, '');
  const last4 = digits.slice(-4) || '0000';
  const first4 = digits.slice(0, 4) || '0000';
  const localPart = (firstName || 'user').toLowerCase() + last4;
  const email = `${localPart}@khadimemillat.org`;
  const username = localPart;
  const password = `${lastName || firstName}@${first4}`; // per spec
  return { firstName, lastName, email, username, password };
}

// GET: list users (from Mongo joined with Clerk data if possible)
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const q = searchParams.get('search') || '';
    await connectDB();
    const mongoQuery = q ? { name: { $regex: q, $options: 'i' } } : {};
    const mongoUsers = await User.find(mongoQuery).select('_id name email phone clerkUserId').sort({ createdAt: -1 }).limit(400).lean();

    // When searching, also query Clerk user list and merge
    if (q) {
      const client: any = typeof clerkClient === 'function' ? await (clerkClient as any)() : clerkClient;
      let clerkUsers: any[] = [];
      try {
        const res = await client.users.getUserList({ query: q, limit: 50 });
        clerkUsers = res?.data || [];
      } catch (err) {
        console.warn('[CLERK_SEARCH_FAILED]', err);
      }
      const mongoMap = new Map<string, any>(mongoUsers.filter(u => u.clerkUserId).map(u => [u.clerkUserId as string, u]));
      const merged = clerkUsers.map(cu => ({
        clerkUserId: cu.id,
        name: `${cu.firstName || ''} ${cu.lastName || ''}`.trim() || cu.username || cu.id,
        email: cu.primaryEmailAddress?.emailAddress,
        mongoUserId: mongoMap.get(cu.id)?._id?.toString(),
        phone: mongoMap.get(cu.id)?.phone,
      }));
      return NextResponse.json({ users: merged });
    }
  // TODO: For consistency, expose both `mongoUserId` and `clerkUserId` keys explicitly
  // Current shape returns `_id` which frontend now maps to mongoUserId.
  return NextResponse.json({ users: mongoUsers });
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

// POST: create Clerk user + Mongo document. Phone stored only in Mongo.
export async function POST(req: NextRequest) {
  try {
    const json = await req.json();
    const parsed = userQuickCreateSchema.parse(json);
    const { firstName, lastName, email, username, password } = deriveIdentity(parsed.name, parsed.mobile);

    // Create user in Clerk (do not store phone there per requirement)
  // Support both direct client object and function returning client
  const client: any = typeof clerkClient === 'function' ? await (clerkClient as any)() : clerkClient;
  const created = await client.users.createUser({
      username,
      emailAddress: [email],
      firstName,
      lastName: lastName || undefined,
      password,
      skipPasswordChecks: true,
      publicMetadata: { role: 'user', autoGenerated: true }
    });

    await connectDB();
    const mongoDoc = await User.create({
      clerkUserId: created.id,
      name: parsed.name,
      email,
      phone: parsed.mobile,
      role: 'user'
    });

    // Patch Clerk user with mongoUserId linkage
    try {
      await client.users.updateUser(created.id, { publicMetadata: { ...created.publicMetadata, mongoUserId: mongoDoc._id.toString() } });
    } catch (err) {
      console.warn('[CLERK_METADATA_PATCH_FAILED]', err);
    }

    return NextResponse.json({
      success: true,
      user: { id: mongoDoc._id.toString(), name: mongoDoc.name, email, phone: mongoDoc.phone, clerkUserId: created.id },
      generated: { username, password }
    }, { status: 201 });
  } catch (err: any) {
    console.error('[CREATE_USER_ERROR]', err);
    return NextResponse.json({ error: err.message }, { status: 400 });
  }
}
